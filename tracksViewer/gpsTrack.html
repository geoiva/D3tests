<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TRACKING GEOGRAPHY &amp; TIME</title>
    <script type="text/javascript" src="../lib/d3.v3.min.js"></script>
    <script src="../lib/d3.geo.projection.v0.min.js"></script>
    <script src="../lib/topojson.v1.min.js"></script>
    <!-- <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script> -->
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<script type="text/javascript">
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*
   TRACKING GEOGRAPHY & TIME
   D3.js Javascript web-aap to generate web pages from track data

  © Barend Köbben, ITC-University of Twente

  Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 License.
  see http://creativecommons.org/licenses/by-nc-sa/3.0/

  @author Barend Kobben <b.j.kobben@utwente.nl>

  @version 0.1.0 [February 2014]
*/

// ##############################################################
// ##############################################################
// FOR EACH NEW DATASET: THE VARIABLES BELOW NEED TO BE SET
//
// geojson file with points & stops:
var dataFile = "data/gpsTrack.geojson";
// lon and lat of center ogf map and map scale:
var mapCenterLon = 6.895, mapCenterLat = 52.219;
var mapScale = 3000000;
// format string for date an/or time formatter
// see https://github.com/mbostock/d3/wiki/Time-Formatting
var dateFormat = d3.time.format("%H:%M:%S");
// lowest and highest time/date values found in data:
var earliestTime = parseMyDate("10:37:32");
var latestTime = parseMyDate("11:05:59");
// lowest and highest distance values found in data:
var smallestDist = 0;
var largestDist = 1466.48;
//Units & interval values for axes:
var distLabelledTicksValue = 20;
var distUnLabelledTicksValue = 100;
var distSlicesLabelledTicksValue = 2;
var distSlicesUnLabelledTicksValue = 10;
var timeLabelledTicksUnit = d3.time.minutes;
var timeLabelledTicksValue = 5;
var timeUnLabelledTicksUnit = d3.time.seconds;
var timeUnLabelledTicksValue = 20;
//
// ##############################################################
// ##############################################################



// *******************
// prepare map panel:
// *******************
//Width and height
var mapWidth = 550;
var mapHeight = 538;
//Define map projection
var projection = d3.geo.mercator()
        .rotate([0,0]) //lon,lat]
        .center([mapCenterLon,mapCenterLat]) //[lon,lat]
        .translate([mapWidth/2, mapHeight/2])
        .precision(0.1)
        .scale([mapScale]);
//Define path generator
var path = d3.geo.path()
        .projection(projection);

//Create SVG element for Map paneL:
var svgMap = d3.select("body")
                .append("svg:svg")
                .attr("id", "mapSVG")
                .attr("width", mapWidth)
                .attr("height", mapHeight)
                .append("svg:g")
        ;
svgMap.append("text")
        .attr("x", 10)
        .attr("y", 35)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("GEOGRAPHY")

// *******************
// prepareTime-distance panels:
// *******************
var distScale, parseDate, timeScale
var SVGscaleWidth = 650, SVGscaleHeight = 170;
var xMargin = 10, yT = 125, yD = 70;
var scaleLength=600;
var track, lines;
var rectHeight = 6; //for rects in scales
//parses string to Date object
function parseMyDate(DateStr) {
    return dateFormat.parse(DateStr);
}


//vars domain for the scales
var timeScale = d3.time.scale()
        .domain([earliestTime, latestTime])
        .range([0, scaleLength]);
var distScale = d3.scale.linear()
        .domain([smallestDist, largestDist])
        .range([0, scaleLength]);

//create SVG placeholders for scale panels:
var svgNormal = d3.select("body").append("svg")
                .attr("id", "svgNormal")
                .attr("width", SVGscaleWidth)
                .attr("height", SVGscaleHeight)
        ;

var svgTime2Geo = d3.select("body").append("svg")
                .attr("id", "svgTime2Geo")
                .attr("width", SVGscaleWidth)
                .attr("height", SVGscaleHeight)
        ;

var svgGeo2Time = d3.select("body").append("svg")
                .attr("id", "svgGeo2Time")
                .attr("width", SVGscaleWidth)
                .attr("height", SVGscaleHeight)
        ;
// gradient def for colour gradienst:
var gradient1 = svgNormal.append("defs")
                .append("linearGradient")
                .attr("id", "gradient1")
                .attr("x1", "0%")
                .attr("y1", "100%")
                .attr("x2", "0%")
                .attr("y2", "0%")
        ;
gradient1.append("stop")
        .attr("offset","0%")
        .attr("style", "stop-color:rgb(255,0,0);stop-opacity:.3")
;
gradient1.append("stop")
        .attr("offset","100%")
        .attr("style", "stop-color:rgb(0,0,255);stop-opacity:.3")
;

// *******************
// prepare panels:
// *******************
//Overall title
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("COMMON REPRESENTATION (both scales fixed)")
;

svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("FROM TIME TO GEOGRAPHY")
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("FROM GEOGRAPHY TO TIME")
;

//DISTANCE

//create generalized axis...
var distAxis = d3.svg.axis()
        .scale(distScale)
        .orient("top")
        .ticks(distLabelledTicksValue)
        .tickSize(10, 0);
;
//...and draw axes with labels
svgNormal.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis)
;
//create detailed axis...
var distAxis2 = d3.svg.axis()
        .scale(distScale)
        .orient("top")
        .ticks(distUnLabelledTicksValue)
        .tickSize(6, 0);
;
//...and draw without labels
svgNormal.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis2)
;
//append top line for
svgNormal.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yD - 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yD - 6)
;
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;
//repeat the drawing for Time2Geo panel:
svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;
//repeat the drawing for Geo2Time panel:
svgGeo2Time.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis)
;
svgGeo2Time.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis2)
;
svgGeo2Time.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yD - 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yD - 6)
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;


//TIME
//create generalized axis...
var timeAxis = d3.svg.axis()
                .scale(timeScale)
                .orient("bottom")
                .ticks(timeLabelledTicksUnit, timeLabelledTicksValue)
                .tickSize(10, 0)
        ;
//...and draw axes with labels
svgNormal.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis)
;
//create detailed axis...
var timeAxis2 = d3.svg.axis()
                .scale(timeScale)
                .orient("bottom")
                .ticks(timeUnLabelledTicksUnit, timeUnLabelledTicksValue)
                .tickSize(6, 0)
        ;
//...and draw axes without labels
svgNormal.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis2)
;
svgNormal.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;
// and repeat all this drawing for Time2Geo panel:
svgTime2Geo.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis)
;
svgTime2Geo.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis2)
;
svgTime2Geo.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;
// and again for Geo2Time panel:
svgGeo2Time.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;

// **********************
// Load in points data and start visualisations
// **********************
d3.json(dataFile, function(error, stop_points) {
    if (error !=null) console.log(error);
    var allPoints = stop_points.features;
    var theStops = stop_points.features.filter(function(d){ return (d.properties.stop == 1 || d.properties.stop == -1); });
    drawMap(allPoints);
    drawNormalPanel(theStops);
    drawTime2GeoPanel(theStops);
    drawGeo2TimePanel(theStops);
});	//end of function loading data


// **********************
// Map Panel:
// **********************
function drawMap(data) {
    svgMap.selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", function (d) {return projection(d.geometry.coordinates)[0];})
            .attr("cy", function (d) {return projection(d.geometry.coordinates)[1];})
            .attr("r","2")
            .attr("class", function (d) {
                if (d.properties.stop == 1) {
                    return "stop";
                } else {
                    return "nostop";
                }
            })
    ;
    svgMap.selectAll("line")
            .data(data)
            .enter()
            .append("line")
            .filter(function(d,i) {return (i+1) < data.length}) //no connector for last point!
            .attr("class", "connectors")
            .attr("x1", function (d) {return projection(d.geometry.coordinates)[0]})
            .attr("y1", function (d) {return projection(d.geometry.coordinates)[1]})
            .attr("x2", function (d,i) {return projection(data[(i+1)].geometry.coordinates)[0]})
            .attr("y2", function (d,i) {return projection(data[(i+1)].geometry.coordinates)[1]})
    ;
} //end drawMap



// **********************
// Normal Panel:
// **********************
function drawNormalPanel(data) {

    //create distance circles
    svgNormal.selectAll(".distancecircle")
//        .data(data)
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {return xMargin+(distScale(d.properties.distance))})
            .attr("cy", yD)
            .attr("r", 3)
    ;

//create connectors
    svgNormal.selectAll(".connectorTriangles")
//            .data(data)
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("path")
            .attr("class", "connectorTriangles")
//            .attr("fill", "url(#gradient1")
            .attr("d", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                if (d.properties.departure != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure)))
                }
                var dStr = "M" + (startX) + " " + yT;
                dStr += " L" + (xMargin+(distScale(d.properties.distance))) + " " + yD;
                dStr += " L" + (endX) + " " + yT;
                return dStr;
            })
    ;
//create time rects
    svgNormal.selectAll(".timecircle")
            .data(data)
//            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("rect")
            .attr("class", "timecircle")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return startX;
            })
            .attr("y", yT - 3)
            .attr("height", rectHeight)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure)))
                }
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return endX - startX;
            })
    ;
}// end of drawNormalPanel



// **********************
// Time To Geography Panel:
// **********************
function drawTime2GeoPanel(data) {

//create connectors
    svgTime2Geo.selectAll(".connectorTriangles")
//            .data(data)
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("rect")
            .attr("class", "connectorTriangles")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return startX;
            })
            .attr("y", yD )
            .attr("height", yT - yD + 3)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure)))
                }
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return endX - startX;
            })
    ;
//create time rects
    svgTime2Geo.selectAll(".timecircle")
            .data(data)
//            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("rect")
            .attr("class", "timecircle")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return startX;
            })
            .attr("y", yT - 3)
            .attr("height", rectHeight)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure)))
                }
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return endX - startX;
            })
    ;
//create distance rects
    svgTime2Geo.selectAll(".distancecircle")
            .data(data)
//            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("rect")
            .attr("class", "distancecircle")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return startX;
            })
            .attr("y", yD - 3)
            .attr("height", rectHeight)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure)))
                }
                if (d.properties.arrival != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival)))
                }
                return endX - startX;
            })
    ;

// create sliced axes
// **********************
    var distScales = new Array;
    var distAxes = new Array;
    var distAxes2 = new Array

    // loop through parts BETWEEN stops
    for (i = 0; i < (data.length-1); i++) {
//        if (data[i].properties.stop == 1) {//filter out non-stops
        var smallestDist = data[i].properties.distance;
        var largestDist = data[i+1].properties.distance;
        // from end of this stop...
        var startX = (timeScale(parseMyDate(data[i].properties.departure)))  + xMargin ;
        // ...to start of next stop...
        var endX = (timeScale(parseMyDate(data[i+1].properties.arrival))) + xMargin ;
        distScales[i] = d3.scale.linear()
                .domain([smallestDist, largestDist])
                .range([startX, endX])
        ;
        svgTime2Geo.append("line")
                .attr("class","axis")
                .attr("x1",startX)
                .attr("y1",yD - 6)
                .attr("x2",endX)
                .attr("y2",yD - 6)
        ;
        // create detailed axis...
        distAxes[i] = d3.svg.axis()
                .scale(distScales[i] )
                .orient("top")
                .ticks(distSlicesUnLabelledTicksValue)
                .tickSize(6, 6)
        ;
        //...and draw it without labels
        svgTime2Geo.append("g")
                .attr("class", "axisNoLabels")
                .attr("transform", "translate(" + (0) + "," + yD +")" )
                .call(distAxes[i])
        ;
        // create generalized axis...
        distAxes2[i] = d3.svg.axis()
                .scale(distScales[i] )
                .orient("top")
                .ticks(distSlicesLabelledTicksValue)
                .tickSize(10, 0)
        ;
        // .. and draw it  with labels
        svgTime2Geo.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (0) + "," + yD +")" )
                .call(distAxes2[i])
        ;
//        } // end filter if
    } // end loop
}// end of drawTime2GeoPanel


// **********************
// Geography to Time Panel:
// **********************
function drawGeo2TimePanel(data) {

//create connectors
    svgGeo2Time.selectAll(".connectorTriangles")
//            .data(data)
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("line")
            .attr("class", "connectorTriangles")
            .attr("x1", function(d) {return xMargin+(distScale(d.properties.distance))})
            .attr("y1", yD )
            .attr("x2", function(d) {return xMargin+(distScale(d.properties.distance))})
            .attr("y2", yT )
    ;

// create sliced axes
// **********************
    var timeScales = new Array;
    var timeAxes = new Array;
    var timeAxes2 = new Array;

    // loop through parts BETWEEN stops
    for (i = 0; i < (data.length-1); i++) {
//        if (data[i].properties.stop == 1) {//filter out non-stops
        var earliestTime = parseMyDate(data[i].properties.departure);
        var latestTime = parseMyDate(data[i+1].properties.arrival);
        // from end of this stop...
        var startX = (distScale(data[i].properties.distance))  + xMargin ;
        // ...to start of next stop...
        var endX = (distScale(data[i+1].properties.distance)) + xMargin ;
        timeScales[i] = d3.time.scale()
                .domain([earliestTime, latestTime])
                .range([startX, endX])
        ;
        // create detailed axis...
        timeAxes[i] = d3.svg.axis()
                .scale(timeScales[i] )
                .orient("bottom")
                .ticks(timeUnLabelledTicksUnit, timeUnLabelledTicksValue)
                .tickSize(6, 6)
        ;
        //...and draw it without labels
        svgGeo2Time.append("g")
                .attr("class", "axisNoLabels")
                .attr("transform", "translate(" + (0) + "," + yT +")" )
                .call(timeAxes[i])
        ;
        // create generalized axis...
        timeAxes2[i] = d3.svg.axis()
                .scale(timeScales[i] )
                .orient("bottom")
                .ticks(timeLabelledTicksUnit, timeLabelledTicksValue)
                .tickSize(10, 0)
        ;
        // .. and draw it  with labels
        svgGeo2Time.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (0) + "," + yT +")" )
                .call(timeAxes2[i])
        ;
//        } // end filter if
    }// end of loop


//create distance circles
    svgGeo2Time.selectAll(".distancecircle")
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {return xMargin+(distScale(d.properties.distance))})
            .attr("cy", yD)
            .attr("r", 3)
    ;
//create time circles
    svgGeo2Time.selectAll(".timecircle")
            .data(data.filter(function(d){ return d.properties.stop == 1; })) //filter out non-stops
            .enter()
            .append("circle")
            .attr("class", "timecircle")
            .attr("cx", function(d) {return xMargin+(distScale(d.properties.distance))})
            .attr("cy", yT)
            .attr("r", 3)
    ;

}// end of drawGeo2TimePanel


</script>
</body>
</html>