<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>D3: Loading GeoJSON data and generating visuali</title>
    <script type="text/javascript" src="../lib/d3.v3.min.js"></script>
    <script src="../lib/d3.geo.projection.v0.min.js"></script>
    <script src="../lib/topojson.v1.min.js"></script>
    <!-- <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script> -->
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<script type="text/javascript">




// *******************
// prepare map panel:
// *******************
//Width and height
var mapWidth = 550;
var mapHeight = 538;
//Define map projection
var projection = d3.geo.mercator()
    .rotate([0,0]) //lon,lat]
    .center([31,55]) //[lon,lat]
    .translate([mapWidth/2, mapHeight/2])
    .precision(0.1)
    .scale([2000]);
//Define path generator
var path = d3.geo.path()
     .projection(projection);

//Create SVG element for Map paneL:
var svgMap = d3.select("body")
    .append("svg:svg")
    .attr("id", "mapSVG")
    .attr("width", mapWidth)
    .attr("height", mapHeight)
    .append("svg:g")
    ;
svgMap.append("text")
        .attr("x", 10)
        .attr("y", 35)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("GEOGRAPHY")

// *******************
// prepareTime-distance panels:
// *******************
var distScale, parseDate, timeScale
var SVGscaleWidth = 650, SVGscaleHeight = 170;
var xMargin = 10, yT = 125, yD = 70;
var scaleLength=600;
var track, lines;
var rectHeight = 6; //for rects in scales
//variables for the  various time-distance visualisations
//var dateFormat = d3.time.format("%d-%m-%YT%H:%M:%S");
var dateFormat = d3.time.format("%d-%m-%Y");
//parses string to Date object
function parseMyDate(DateStr) {
    return dateFormat.parse(DateStr);
}

//TODO: these min-max values should be really be retrieved from data:
var earliestTime = parseMyDate("30-06-1812");
var latestTime = parseMyDate("12-12-1812");
var smallestDist = 0;
var largestDist = 31;
//TODO: The distance values are phony values "in degrees". NEEDS TO CHANGE!

//vars domain for the scales
var timeScale = d3.time.scale()
        .domain([earliestTime, latestTime])
        .range([0, scaleLength]);
var distScale = d3.scale.linear()
        .domain([smallestDist, largestDist])
        .range([0, scaleLength]);

//create SVG placeholders for scale panels:
var svgNormal = d3.select("body").append("svg")
        .attr("id", "svgNormal")
        .attr("width", SVGscaleWidth)
        .attr("height", SVGscaleHeight)
;

var svgTime2Geo = d3.select("body").append("svg")
        .attr("id", "svgTime2Geo")
        .attr("width", SVGscaleWidth)
        .attr("height", SVGscaleHeight)
;

var svgGeo2Time = d3.select("body").append("svg")
        .attr("id", "svgGeo2Time")
        .attr("width", SVGscaleWidth)
        .attr("height", SVGscaleHeight)
;
// gradient def for colour gradienst:
var gradient1 = svgNormal.append("defs")
        .append("linearGradient")
        .attr("id", "gradient1")
        .attr("x1", "0%")
        .attr("y1", "100%")
        .attr("x2", "0%")
        .attr("y2", "0%")
        ;
gradient1.append("stop")
        .attr("offset","0%")
        .attr("style", "stop-color:rgb(255,0,0);stop-opacity:.3")
        ;
gradient1.append("stop")
        .attr("offset","100%")
        .attr("style", "stop-color:rgb(0,0,255);stop-opacity:.3")
        ;

// *******************
// prepare scale panels:
// *******************
//Overall title
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("COMMON REPRESENTATION (both scales fixed)")
;

svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("FROM TIME TO GEOGRAPHY")
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yD-40)
        .attr("fill", "red")
        .attr("font-size", 20)
        .text("FROM GEOGRAPHY TO TIME")
;

//DISTANCE
// set properties of distance axis:
var distAxis = d3.svg.axis()
        .scale(distScale)
        .orient("top")
        .ticks(20)
        .tickSize(10, 0);
;
var distAxis2 = d3.svg.axis()
        .scale(distScale)
        .orient("top")
        .ticks(200)
        .tickSize(6, 0);
;
//draw axes + text for distance for each scale
svgNormal.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis)
;
svgNormal.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis2)
;
svgNormal.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yD - 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yD - 6)
;
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;

//svgTime2Geo.append("g")
//        .attr("class", "axis")
//        .attr("transform", "translate(" + xMargin + "," + yD +")" )
//        .call(distAxis)
//;
//svgTime2Geo.append("g")
//        .attr("class", "axisNoLabels")
//        .attr("transform", "translate(" + xMargin + "," + yD +")" )
//        .call(distAxis2)
//;
svgTime2Geo.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yD - 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yD - 6)
;
svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;

svgGeo2Time.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis)
;
svgGeo2Time.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yD +")" )
        .call(distAxis2)
;
svgGeo2Time.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yD - 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yD - 6)
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yD-22)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("DISTANCE")
;


//TIME
// set properties of time axes:
var timeAxis = d3.svg.axis()
        .scale(timeScale)
        .orient("bottom")
        .ticks(d3.time.months, 1)
        .tickSize(10, 0)
        ;
var timeAxis2 = d3.svg.axis()
        .scale(timeScale)
        .orient("bottom")
        .ticks(d3.time.days, 1)
        .tickSize(6, 0)
        ;
//draw axes + text for time, for each scale
svgNormal.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis)
;
svgNormal.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis2)
;
svgNormal.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgNormal.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;

svgTime2Geo.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis)
;
svgTime2Geo.append("g")
        .attr("class", "axisNoLabels")
        .attr("transform", "translate(" + xMargin + "," + yT +")" )
        .call(timeAxis2)
;
svgTime2Geo.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgTime2Geo.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;

//svgGeo2Time.append("g")
//        .attr("class", "axis")
//        .attr("transform", "translate(" + xMargin + "," + yT +")" )
//        .call(timeAxis)
//;
//svgGeo2Time.append("g")
//        .attr("class", "axisNoLabels")
//        .attr("transform", "translate(" + xMargin + "," + yT +")" )
//        .call(timeAxis2)
//;
svgGeo2Time.append("line")
        .attr("class","axis")
        .attr("x1",xMargin)
        .attr("y1",yT + 6)
        .attr("x2",xMargin + scaleLength)
        .attr("y2",yT + 6)
;
svgGeo2Time.append("text")
        .attr("x", xMargin)
        .attr("y", yT+30)
        .attr("fill", "grey")
        .attr("font-size", 10)
        .text("TIME")
;

// Load in points data and start visualisations
d3.json("data/Nap_1812_IV_Corps.geojson", function(error, stop_points) {
    var theStops=stop_points.features; //store array to use later for connectors & timescales
    drawMap(theStops);
    drawNormalPanel(theStops);
    drawTime2GeoPanel(theStops);
    drawGeo2TimePanel(theStops);
});	//end of function loading data


// MAP panel:
function drawMap(data) {
    svgMap.selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", function (d) {return projection(d.geometry.coordinates)[0];})
            .attr("cy", function (d) {return projection(d.geometry.coordinates)[1];})
            .attr("r","2")
            .attr("class", "stop")
    ;
    svgMap.selectAll("line")
            .data(data)
            .enter()
            .append("line")
            .filter(function(d,i) {return (i+1) < data.length}) //no connector for last stop!
            .attr("class", "connectors")
            .attr("x1", function (d) {return projection(d.geometry.coordinates)[0]})
            .attr("y1", function (d) {return projection(d.geometry.coordinates)[1]})
            .attr("x2", function (d,i) {return projection(data[(i+1)].geometry.coordinates)[0]})
            .attr("y2", function (d,i) {return projection(data[(i+1)].geometry.coordinates)[1]})
    ;
} //end drawMap



//COMMON panel
//create distance events

function drawNormalPanel(data) {

    svgNormal.selectAll(".distancecircle")
        .data(data)
        .enter()
        .append("circle")
        .attr("class", "distancecircle")
        .attr("cx", function(d) {return xMargin+(distScale(d.properties.distance_degrees))})
        .attr("cy", yD)
        .attr("r", 3)
    ;

//create connectors
    svgNormal.selectAll(".connectorTriangles")
            .data(data)
            .enter()
            .append("path")
            .attr("class", "connectorTriangles")
//            .attr("fill", "url(#gradient1")
            .attr("d", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                if (d.properties.departure_date != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure_date)))
                }
                var dStr = "M" + (startX) + " " + yT;
                dStr += " L" + (xMargin+(distScale(d.properties.distance_degrees))) + " " + yD;
                dStr += " L" + (endX) + " " + yT;
                return dStr;
            })
    ;
//create time rects
    svgNormal.selectAll(".timecircle")
        .data(data)
        .enter()
        .append("rect")
        .attr("class", "timecircle")
        .attr("x", function(d) {
            var startX = xMargin + 0;
            if (d.properties.arrival_date != null) {
                startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
            }
            return startX;
            })
        .attr("y", yT - 3)
        .attr("height", rectHeight)
        .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure_date != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure_date)))
                }
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
            return endX - startX;
        })
    ;

}// end of drawFunction

// Time To Geography Panel:
function drawTime2GeoPanel(data) {

//create connectors
    svgTime2Geo.selectAll(".connectorTriangles")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "connectorTriangles")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return startX;
            })
            .attr("y", yD + 3 )
            .attr("height", yT - yD)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure_date != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure_date)))
                }
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return endX - startX;
            })
    ;

//create time rects
    svgTime2Geo.selectAll(".timecircle")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "timecircle")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return startX;
            })
            .attr("y", yT - 3)
            .attr("height", rectHeight)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure_date != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure_date)))
                }
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return endX - startX;
            })
    ;

//create distance rects
    svgTime2Geo.selectAll(".distancecircle")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "distancecircle")
            .attr("x", function(d) {
                var startX = xMargin + 0;
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return startX;
            })
            .attr("y", yD - 3)
            .attr("height", rectHeight)
            .attr("width", function(d) {
                var startX = xMargin + 0, endX = xMargin + scaleLength;
                if (d.properties.departure_date != null) {
                    endX = xMargin+(timeScale(parseMyDate(d.properties.departure_date)))
                }
                if (d.properties.arrival_date != null) {
                    startX = xMargin+(timeScale(parseMyDate(d.properties.arrival_date)))
                }
                return endX - startX;
            })
    ;


// **********************
// create sliced axes
// **********************
    var distScales = new Array;
    var distAxes = new Array;
    var distAxes2 = new Array;


    // loop through parts BETWEEN stops
    for (i = 0; i < (data.length-1); i++) {
        var smallestDist = data[i].properties.distance_degrees;
        var largestDist = data[i+1].properties.distance_degrees;
        // from end of this stop...
        var startX = (timeScale(parseMyDate(data[i].properties.departure_date)))  + xMargin ;
        // ...to start of next stop...
        var endX = (timeScale(parseMyDate(data[i+1].properties.arrival_date))) + xMargin ;
        distScales[i] = d3.scale.linear()
                .domain([smallestDist, largestDist])
                .range([startX, endX])
        ;
        // create detailed axis...
        distAxes[i] = d3.svg.axis()
                .scale(distScales[i] )
                .orient("top")
                .ticks(5)
                .tickSize(6, 6)
        ;
        //...and draw it without labels
        svgTime2Geo.append("g")
                .attr("class", "axisNoLabels")
                .attr("transform", "translate(" + (0) + "," + yD +")" )
                .call(distAxes[i])
        ;
        // create generalized axis...
        distAxes2[i] = d3.svg.axis()
                .scale(distScales[i] )
                .orient("top")
                .ticks(1)
                .tickSize(10, 0)
        ;
        // .. and draw it  with labels
        svgTime2Geo.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (0) + "," + yD +")" )
                .call(distAxes2[i])
        ;
    }





}// end of drawFunction


// Geography to Time Panel:
function drawGeo2TimePanel(data) {


//create connectors
    svgGeo2Time.selectAll(".connectorTriangles")
            .data(data)
            .enter()
            .append("line")
            .attr("class", "connectorTriangles")
            .attr("x1", function(d) {return xMargin+(distScale(d.properties.distance_degrees))})
            .attr("y1", yD )
            .attr("x2", function(d) {return xMargin+(distScale(d.properties.distance_degrees))})
            .attr("y2", yT )
    ;
//create time rects
    svgGeo2Time.selectAll(".distancecircle")
            .data(data)
            .enter()
            .append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {return xMargin+(distScale(d.properties.distance_degrees))})
            .attr("cy", yD)
            .attr("r", 3)
    ;


// **********************
// create sliced axes
// **********************
    var timeScales = new Array;
    var timeAxes = new Array;
    var timeAxes2 = new Array;


    // loop through parts BETWEEN stops
    for (i = 0; i < (data.length-1); i++) {
        var earliestTime = parseMyDate(data[i].properties.departure_date);
        var latestTime = parseMyDate(data[i+1].properties.arrival_date);
        // from end of this stop...
        var startX = (distScale(data[i].properties.distance_degrees))  + xMargin ;
        // ...to start of next stop...
        var endX = (distScale(data[i+1].properties.distance_degrees)) + xMargin ;
        timeScales[i] = d3.time.scale()
                .domain([earliestTime, latestTime])
                .range([startX, endX])
        ;

        if (1==1) {
        // create detailed axis...
        timeAxes[i] = d3.svg.axis()
                .scale(timeScales[i] )
                .orient("bottom")
                .ticks(10)
                .tickSize(6, 6)
        ;
        //...and draw it without labels
        svgGeo2Time.append("g")
                .attr("class", "axisNoLabels")
                .attr("transform", "translate(" + (0) + "," + yT +")" )
                .call(timeAxes[i])
        ;
        // create generalized axis...
        timeAxes2[i] = d3.svg.axis()
                .scale(timeScales[i] )
                .orient("bottom")
                .ticks(.5)
                .tickSize(10, 0)
        ;
        // .. and draw it  with labels
        svgGeo2Time.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (0) + "," + yT +")" )
                .call(timeAxes2[i])
        ;
        }

    }



}// end of drawFunction


</script>
</body>
</html>