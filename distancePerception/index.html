<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Equal Distance from Utrecht</title>
<style>
    @import url(../lib/maps.css);
.distance, .land {
  fill: none;
  stroke: #000;
  stroke-width: .5px;
}
.land {
  fill: #eee;
  stroke: none;
}
.countries {
  fill: none;
  stroke: #444;
  stroke-width: .3px;
}
.graticule {
  fill: none;
  stroke: #000;
  stroke-opacity: .5;
  stroke-width: .5px;
}
.outline {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  pointer-events: all;
}
.mouse {
  pointer-events: none;
  font-size: 12px;
}
.pointer {
  pointer-events: none;
  fill: none;
  stroke: #000;
  stroke-dasharray: 5,5;
}
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.axis {
  font-size: 12px;
}
svg {
  cursor: crosshair;
}
.citycircle {
    fill : red;
    stroke : none;
}
.distancecircle {
    fill : blue;
    stroke : none;
}
.connectors {
    fill : none;
    stroke : black;
    stroke-width : .1pt;
}
text {
    fill : black;
    stroke : none;
}
</style>

<script src="../lib/d3.v3.min.js"></script>
<script src="../lib/topojson.v1.min.js"></script>

<body>
<div id="equidistant"></div>

<script>

var width = 600,
    height = 600,
    π = Math.PI,
    radians = π / 180,
    radius = 6371,
    format = d3.format(",.0f")
    mapscale = 1000
    ;

var cities =  {features: [
        {name: "Utrecht", coordinates: [5.115556, 52.088889]},
        {name: "Athene", coordinates: [23.727778, 37.977778]}
        ]};

var projCentre = cities.features[0].coordinates; //= Utrecht

var equidistant = d3.geo.azimuthalEquidistant()
    .translate([width/2, height/2])
    .clipAngle(180 - 1e-3)
    .scale(mapscale)
    .precision(.1)
    .rotate([-projCentre[0], -projCentre[1]])
    ;

var svg = d3.selectAll("#equidistant")
    .data([equidistant].map(function(projection) { return d3.geo.path().projection(projection); }))
  .append("svg")
    .attr("width", width)
    .attr("height", height)
    ;

svg.insert("path", ".distance")
    .datum(d3.geo.graticule())
    .attr("class", "graticule");

svg.append("path")
        .datum({type: "Sphere"})
        .attr("class", "outline");

var pointer = svg.append("path")
    .attr("class", "pointer");

var mouseDistance = svg.append("text").attr("class", "mouse");

svg.each(function(path) {
    var projection = path.projection();
    d3.select(this).selectAll(".outline")
            .on("mousemove", function() {
                mouse = projection.invert(d3.mouse(this));
                d3.event.stopPropagation();
                pointer.each(updatePointer);
            });
});


function updatePointer(path) {
    var m = path.projection()(mouse),
      pointer = d3.select(this).style("display", null);
    var dx = m[0] - width / 2,
        dy = m[1] - height / 2,
        a = Math.atan2(dy, dx),
        r = Math.sqrt(dx * dx + dy * dy);
    pointer.attr("d", "M" + [width / 2, height/2] + "l" + [mapscale * Math.PI * Math.cos(a), mapscale * Math.PI * Math.sin(a)] +
        "M" + m + "a" + [r, r, 0, 0, 1, -2 * dx, -2 * dy] + "A" + [r, r, 0, 0, 1, m]);
    mouseDistance
        .attr("transform", "translate(" + [width / 2, height/2] + ")rotate(" + a / radians + ")translate(" + r + ")" +
                    "rotate(" + (Math.abs(a) > Math.PI / 2 ? 180 : 0) + ")")
        .attr("text-anchor", Math.abs(a) < Math.PI / 2 ^ r / mapscale > Math.PI / 2 ? "start" : "end")
        .attr("dx", Math.abs(a) < Math.PI / 2 ^ r / mapscale > Math.PI / 2 ? "1em" : "-1em")
        .attr("dy", "-.3em")
        .text(format(r / mapscale * radius) + "km");
}


d3.json("../data/world-50m.json", function(error, world) {
  var land = topojson.feature(world, world.objects.land);
  var countries = topojson.mesh(world, world.objects.countries);
  svg.insert("path", ".graticule")
      .datum(land)
      .attr("class", "land")
  svg.insert("path", ".graticule")
      .datum(countries)
      .attr("class", "countries")
  svg.each(redraw);
});


svg.selectAll("circle", ".citycircle")
    .data(cities.features).enter()
        .append("circle")
        .attr("class", "citycircle")
        .attr("cx", function(d) {return equidistant(d.coordinates)[0]} )
        .attr("cy", function(d) {return equidistant(d.coordinates)[1]} )
        .attr("id", function(d) {return (d.name)} )
        .attr("r", 10)
    ;
svg.each(redraw);


function redraw(path) {
    d3.select(this).selectAll(".land,.graticule,.countries,.outline").attr("d", path);
}


////Encode the SVG DOM for saving
//var serializer = new XMLSerializer();
//var xmlString = serializer.serializeToString(d3.select('svg').node());
//var imgData = 'data:image/svg+xml;base64,' + btoa(xmlString);
////Use the download attribute (or a shim) to provide a link
//document.write("<a href=");
//document.write(imgData);
//document.write(" download='download'>Download</a>");


</script>
</body>
</html>